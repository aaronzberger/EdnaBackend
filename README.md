# BetterVote Canvassing Backend

This package is the backend for the BetterVote canvassing technology, and temporarily contains the processing for ingesting and pre-processing campaign data.

<img src="https://user-images.githubusercontent.com/35245591/147997445-bb23eec5-8b0c-480c-b283-603f23c5d218.png" alt="Associations" width="589" height="412">

## Table of Contents
- [Overview](#Overview)
- [Details](#Details)
  - [Data Structuring](#Data-Structuring)
    - [Typing](#Typing)
    - [Distance matrices](#Distance-matrices)
  - [Pre-processing](#Pre-processing)
    - [Geographic data fetching](#Geographic-data-fetching)
    - [Geographic data parsing](#Geographic-data-parsing)
    - [Block creation](#Block-creation)
    - [Universe matching](#Universe-matching)
  - [Route Optimization](#Route-Optimization)
    - [Problem Formulation](#Problem-Formulation)
    - [Solving](#Solving)
    - [Post-processing](#Post-processing)
    - [Visualization](#Visualization)


# Details
The usage of this package is documented throughout the sections below, instead of in a separate section, due to the number of scripts and steps involved. First, let's explore the general principles we use to structure the data.

## Data Structuring
There are multiple de-coupling steps which make BetterVote's final product adaptable, scalable, and understandable. Within the backend, de-coupling the structure of the data with the functionality of the backend is critical to being able to adapt to new functionality and data.

The schema we use is documented at the bottom of the Swagger API documentation [here](#https://aaronzberger.github.io/EdnaArchitecture/). The rest of the API documentation is also worth exploring, to better understand the purpose of the backend (the outputs).

The geographic structuring is as follows: a `Block` is the segment of road between two possible turning points. A `Block` contains `node`s, which are the `Point`s making up the grographical structure of the line segment. A `Block` also contains `Abode`s, which are places where voters live (this could be a house, apartment within a building, etc.). `Abode`s contain one or more `Voter`s.

### Typing
The objects described in this schema are implemented as `TypedDict` objects in Python, with nearly precisely the same attributes as are on the Swagger documentation (and we attempt to keep these consistent). For example, look at the `Voter` type in the Swagger schema, and compare it with the `Voter` class in `src/config.py` (they're the same). We use `TypedDict` objects for easy reading and writing to JSON, and for easy stringification for storing in Redis.

### Distance Matrices
Throughout the backend, it becomes necessary to frequently calculate distances between `Block`s, `node`s, and `Abode`s. Due to the large number of `Abode`s, we choose to pre-process the distance matrices for `node`s and `Block`s (and store them in Redis, see TODO below, which adds these distances if needed for each new campaign), but not for `Abode`s. For `Abode`s, we calculate the distance matrices only at the time of optimization, in small clusters. Thus, there is no central storage of `Abode` distances.

The `node` distance matrix (in `src/distances/nodes.py`) is the only distance matrix which is generated by actually performing routing. It stores the distances between each intersection.

The `Block` distance matrix (which stores the shortest distance between any two endpoints between two `Block`s) simply uses the `node` distance matrix to calculate the distance between each `Block` (in `src/distances/blocks.py`).

The `Abode` distance matrix similarly uses the `Block` distance matrix, along with the information within each `AbodeGeography` object to calculate distances (in `src/distances/abodes.py`).


## Pre-processing
The goal of the pre-processing is to take a campaign's geographic information (what areas they are running in), and prepare the data for canvassing, and to be used in the CRM. The inputs to the pre-processing are:
 - The campaign's "universe" file, which contains a subset of the public voter file, containing only the voters the campaign wants to target (see `regions/dev_1/input/universe.csv` for an example).
 - Geocoding information, which maps an address to coordinates. Right now, we test in Alleghney County, PA, which releases a file with this information (see `input/address_pts.csv`). **This will soon transition to a scalable solution like SmartyStreets, which has geocoding and address matching.**

### Geographic Data Fetching
First, we use OpenStreetMap (OSM) to retrieve a geographic understanding of the region requested: blocks and nodes. Run `src/pre_processing/get_data.py` to query OSM for the bounding box defined in `src/config.py`. This may take a while, but finally generates a large file called `overpass.json`.

### Geographic Data Parsing
Next, we process the raw data in `overpass.json` into a more usable format. Run `src/pre_processing/preprocess_data.py` to generate `block_output.json`, which contains all the blocks and nodes in the region. This file is structured as follows:
```
{
    "node_id": [
        [
            "another_node_id",
            0 or 1,
            {
                "nodes": [list of node IDs],
                "ways": [
                  [
                    way ID
                    way info
                  ],
                  [
                    another way ID
                    another way info
                  ],
                  ...
                ]
            }
        ],
        ...
    ],
    ...
}
```

We also can now store the coordinates of all the nodes in the region for quick access later. Run `src/pre_processing/parse_json.py` to store the nodes from `overpass.json` file into Redis.

### Block Creation
Now, with our understanding of nodes and blocks, we can create the actual `Block` objects and store them in Redis. This involves associating the abodes with the blocks, and creating the `Abode` and `Block` objects fully (apart from adding voters to the `Abode`s). Run `src/pre_processing/make_blocks.py`. **This will soon transition to SmartyStreets or equivalent, which provides unique abode keying, address matching, etc.**

### Universe Matching
Finally, we can associate the `universe.csv` file with these `Abode`s and add the voters to their respective `Abode`s. Run `src/pre_processing/process_universe.py` to do this. This also pre-populates the distance matrices for `node`s and `Block`s to save time later. **This will also soon change once a scalable address matching system is implemented, since the current matching between `Abode`s and `universe.csv` is not scalable.**
